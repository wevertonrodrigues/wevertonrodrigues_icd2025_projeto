---
title: "An√°lise Explorat√≥ria de Dados"
subtitle: "Introdu√ß√£o √† Infer√™ncia Estat√≠stica- Parte 1"
lang: pt-BR
author: "Seu Nome"
date: 2025-06-25
format: 
  html:
    theme: flatly
    embed-resources: true
    toc: true
    number-sections: true
execute:
  echo: true
  message: false
  warning: false
---


```{r}
#| label: setup
#| echo: false

# configura exibi√ß√£o de n√∫meros
options(digits = 5, scipen = 999)

# carrega os pacotes necess√°rios
library(tidyverse)  # Inclui dplyr, tidyr, ggplot2...
library(patchwork)  # Para combinar gr√°ficos
library(abjData)    # Dados municipais do PNUD
library(sampling)   # T√©cnicas cl√°ssicas de amostragem
```




# Popula√ß√£o e Amostra 

## Qualidade do Whisky: Popula√ß√£o e Amostra

```{r}
#| echo: false

# Este c√≥digo simula uma situa√ß√£o que todo analista enfrenta:
# conhecer apenas uma pequena parte dos dados que realmente importam

# Fixa a semente para garantir que todos obtenham exatamente os mesmos resultados
# Isso √© importante para fins did√°ticos
set.seed(42)

# POPULA√á√ÉO: Simula todos os 46.000 barris da destilaria
# Na vida real, o analista N√ÉO teria acesso a estes dados completos
# Estamos simulando apenas para fins ilustrativos
populacao_barris <- tibble(
  # Cria um ID √∫nico para cada barril (de 1 at√© 46.000)
  barril_id = 1:46000,
  
  # Simula a pontua√ß√£o real de qualidade de cada barril
  # rnorm() gera n√∫meros aleat√≥rios seguindo distribui√ß√£o normal
  # mean = 7.2 significa que a qualidade m√©dia real √© 7.2 pontos
  # sd = 0.9 significa que o desvio padr√£o real √© 0.9 pontos
  pontuacao = rnorm(46000, mean = 7.2, sd = 0.9)
) %>%
  # Ajusta as pontua√ß√µes para ficarem dentro de uma escala realista (1 a 10)
  # pmin(10, ...) garante que nenhum valor seja maior que 10
  # pmax(1, ...) garante que nenhum valor seja menor que 1
  mutate(pontuacao = pmin(10, pmax(1, pontuacao)))

# Calcula os PAR√ÇMETROS POPULACIONAIS - os valores verdadeiros 
# Na pr√°tica, estes valores s√£o desconhecidos para o analista
parametros_reais <- tibble(
  # Nomeia cada caracter√≠stica que estamos medindo
  `Caracter√≠stica` = c("Tamanho (N)", "Qualidade m√©dia (Œº)", "Desvio padr√£o (œÉ)"),
  
  # Calcula os par√°metros da popula√ß√£o
  `Valor Real` = c(
    # Conta o n√∫mero total de barris na popula√ß√£o
    format(nrow(populacao_barris), big.mark = "."),
    # Calcula a m√©dia real de qualidade (par√¢metro Œº)
    round(mean(populacao_barris$pontuacao), 2),
    # Calcula o desvio padr√£o real (par√¢metro œÉ)
    round(sd(populacao_barris$pontuacao), 2)
  ),
  
  # Explica o que cada valor significa 
  `Significado` = c(
    "Total de barris produzidos em 2024",
    "Qualidade m√©dia de toda a produ√ß√£o",
    "Variabilidade da qualidade dos barris"
  )
)

# Mostra os par√¢metros populacionais 
parametros_reais

# AMOSTRA: Simula o que o analista realmente faz na pr√°tica
# slice_sample() seleciona aleatoriamente 50 barris da popula√ß√£o completa
# Isto representa o processo real de amostragem que um analista executaria
amostra_barris <- populacao_barris %>%
  slice_sample(n = 50)  # Seleciona exatamente 50 barris de forma aleat√≥ria

# Calcula as ESTAT√çSTICAS AMOSTRAIS - Estes s√£o os valores que o analista 
# realmente calcula e usa para fazer infer√™ncias
estatisticas_observadas <- tibble(
  # Nomeia cada estat√≠stica 
  `Caracter√≠stica` = c("Tamanho (n)", "Qualidade m√©dia (xÃÑ)", "Desvio- padr√£o (s)"),
  
  # Estimativas dos par√¢metros populacionais baseadas na amostra
  `Valor Calculado` = c(
    # Conta quantos barris foram efetivamente testados
    nrow(amostra_barris),
    # Calcula a m√©dia da amostra (estat√≠stica xÃÑ) 
    # Esta √© nossa melhor estimativa de Œº
    round(mean(amostra_barris$pontuacao), 2),
    # Calcula o desvio padr√£o da amostra (estat√≠stica s)
    # Esta √© nossa melhor estimativa de œÉ
    round(sd(amostra_barris$pontuacao), 2)
  ),
  
  # Significado de cada estat√≠stica
  `Interpreta√ß√£o` = c(
    "amostra",
    "estimativa de Œº",
    "estimativa do œÉ"
  )
)

# exibe as estat√≠sticas amostrais
estatisticas_observadas
```




## Compara√ß√£o: Par√¢metros vs Estimativas

```{r}
#| echo: false

# Cria uma tabela comparativa lado a lado para visualizar a qualidade das estimativas
comparacao_completa <- tibble(
  # Lista as medidas que estamos comparando
  Medida = c("Tamanho", "Qualidade M√©dia", "Desvio Padr√£o"),
  
  # Coluna com valores populacionais (que seriam desconhecidos na pr√°tica)
  # Inclu√≠mos os s√≠mbolos matem√°ticos para refor√ßar a nota√ß√£o
  `Popula√ß√£o` = c(
    # Formata o tamanho populacional com separador de milhares
    paste("N =", format(nrow(populacao_barris), big.mark = ".")),
    # Mostra a m√©dia populacional verdadeira (Œº)
    paste("Œº =", round(mean(populacao_barris$pontuacao), 2)),
    # Mostra o desvio padr√£o populacional verdadeiro (œÉ)
    paste("œÉ =", round(sd(populacao_barris$pontuacao), 2))
  ),
  
  # Coluna com valores amostrais (o que o analista realmente calcula e conhece)
  `Amostra` = c(
    # Mostra o tamanho da amostra
    paste("n =", nrow(amostra_barris)),
    # Mostra a m√©dia amostral (xÃÑ) - nossa estimativa de Œº
    paste("xÃÑ =", round(mean(amostra_barris$pontuacao), 2)),
    # Mostra o desvio padr√£o amostral (s) - nossa estimativa de œÉ
    paste("s =", round(sd(amostra_barris$pontuacao), 2))
  ),
  
  # Avalia qu√£o boa √© cada estimativa
  # Esta avalia√ß√£o nos ajuda a entender a qualidade da amostragem
  `Qualidade da Estimativa` = c(
    # Para o tamanho, mostramos a propor√ß√£o que a amostra representa
    "Amostra = 0,11% da popula√ß√£o",
    
    # Para a m√©dia, avaliamos se a diferen√ßa √© pequena (< 0.2 pontos)
    # abs() calcula o valor absoluto da diferen√ßa
    ifelse(abs(mean(amostra_barris$pontuacao) - mean(populacao_barris$pontuacao)) < 0.2, 
           "Boa estimativa", "Estimativa razo√°vel"),
    
    # Para o desvio padr√£o, usamos o mesmo crit√©rio (< 0.2 pontos de diferen√ßa)
    ifelse(abs(sd(amostra_barris$pontuacao) - sd(populacao_barris$pontuacao)) < 0.2, 
           "Boa estimativa", "Estimativa razo√°vel")
  )
)

# Exibe a tabela comparativa completa
comparacao_completa
```




## Verifica√ß√£o Visual da Representatividade

```{r}
#| label: visualizacao-comparativa
#| echo: false


# Para a popula√ß√£o, usamos apenas uma subamostra para facilitar a visualiza√ß√£o
# slice_sample(n = 2000) pega 2000 barris aleatoriamente para o gr√°fico
# (plotar todos os 46.000 pontos deixaria o gr√°fico muito pesado)
dados_pop_visual <- populacao_barris %>% 
  slice_sample(n = 2000) %>%
  # Adiciona r√≥tulo para identificar nos gr√°ficos
  mutate(grupo = "Popula√ß√£o (N = 46.000)")

# Para a amostra, usamos todos os 50 barris coletados
dados_amostra_visual <- amostra_barris %>%
  # Adiciona r√≥tulo correspondente
  mutate(grupo = "Amostra (n = 50)")

# Calcula as m√©dias para adicionar linhas de refer√™ncia nos gr√°ficos
# Estas linhas ajudam a comparar visualmente os centros das distribui√ß√µes
media_pop <- mean(populacao_barris$pontuacao)      # M√©dia populacional (Œº)
media_amostra <- mean(amostra_barris$pontuacao)    # M√©dia amostral (xÃÑ)

# Cria o gr√°fico da distribui√ß√£o populacional
p1 <- ggplot(dados_pop_visual, aes(x = pontuacao)) +
  # geom_density() cria uma curva suave mostrando a forma da distribui√ß√£o
  # fill e alpha controlam a cor e transpar√™ncia
  geom_density(fill = "#bdc9e1", alpha = 0.7, color = "#2c3e50", linewidth = 1) +
  
  # Adiciona linha vertical na m√©dia populacional
  # Esta linha mostra onde est√° o centro "verdadeiro" da distribui√ß√£o
  geom_vline(xintercept = media_pop, 
             linetype = "dashed", color = "#2c3e50", linewidth = 1.2) +
  
  # Adiciona texto mostrando o valor da m√©dia populacional
  # annotate() permite colocar texto em posi√ß√£o espec√≠fica do gr√°fico
  annotate("text", x = media_pop + 0.3, y = 0.35, 
           label = paste("Œº =", round(media_pop, 2)), 
           color = "#2c3e50", hjust = 0, size = 4, fontface = "bold") +
  
  # Define t√≠tulos e r√≥tulos do gr√°fico
  labs(
    title = "Distribui√ß√£o da Popula√ß√£o",
    subtitle = "Qualidade real de todos os barris (desconhecida na pr√°tica)",
    x = "Pontua√ß√£o de Qualidade", y = "Densidade"
  ) +
  theme_minimal()

# Cria o gr√°fico da distribui√ß√£o amostral
p2 <- ggplot(dados_amostra_visual, aes(x = pontuacao)) +
  # geom_histogram() mostra a distribui√ß√£o atrav√©s de barras
  # bins = 12 divide os dados em 12 intervalos (adequado para n=50)
  geom_histogram(bins = 12, fill = "#fd8d3c", alpha = 0.8, color = "white") +
  
  # Adiciona linha vertical na m√©dia amostral
  # Esta linha mostra onde est√° o centro da nossa amostra
  geom_vline(xintercept = media_amostra, 
             color = "#d73027", linewidth = 1.2) +
  
  # Adiciona texto mostrando o valor da m√©dia amostral
  annotate("text", x = media_amostra + 0.3, y = 4.5, 
           label = paste("xÃÑ =", round(media_amostra, 2)), 
           color = "#d73027", hjust = 0, size = 4, fontface = "bold") +
  
  # Define t√≠tulos e r√≥tulos do gr√°fico
  labs(
    title = "Distribui√ß√£o da Amostra",
    subtitle = "Qualidade observada nos barris testados (dados dispon√≠veis)",
    x = "Pontua√ß√£o de Qualidade", y = "Frequ√™ncia"
  ) +
  theme_minimal()

# Combina os dois gr√°ficos verticalmente usando o operador / do patchwork
# Isso permite comparar visualmente as duas distribui√ß√µes
p1 / p2
```



## Exemplo: Satisfa√ß√£o de Clientes

Analista de e-commerce com 50.000 clientes ativos precisa estimar 
satisfa√ß√£o m√©dia para estrat√©gias de reten√ß√£o. Entrevistar todos 
seria proibitivo. Solu√ß√£o: amostra de 80 clientes para obter uma
estimativa confi√°vel.


```{r}
#| echo: false

# Este exemplo mostra uma situa√ß√£o muito comum em empresas:
# precisar conhecer caracter√≠sticas de uma grande base de clientes
# usando apenas uma pequena amostra por quest√µes de custo e tempo

# Fixa semente para reprodutibilidade dos resultados did√°ticos
set.seed(123)

# Simula a base completa de clientes da empresa
# Na realidade, esta seria a base de dados real da empresa
base_clientes <- tibble(
  # Cria ID √∫nico para cada um dos 50.000 clientes
  cliente_id = 1:50000,
  
  # Simula n√≠vel de satisfa√ß√£o de cada cliente
  # rnorm() gera valores seguindo distribui√ß√£o normal
  # mean = 7.5 indica que a satisfa√ß√£o m√©dia real √© 7.5 pontos
  # sd = 1.2 indica que o desvio padr√£o real √© 1.2 pontos
  satisfacao = rnorm(50000, mean = 7.5, sd = 1.2)
) %>%
  # Ajusta valores para ficarem na escala v√°lida de satisfa√ß√£o (0 a 10)
  # pmax(0, ...) garante que nenhum valor seja negativo
  # pmin(10, ...) garante que nenhum valor seja maior que 10
  mutate(satisfacao = pmax(0, pmin(10, satisfacao)))

# Calcula os PAR√ÇMETROS POPULACIONAIS - o que queremos descobrir
# Em uma situa√ß√£o real, estes valores seriam completamente desconhecidos
parametros_satisfacao <- tibble(
  # Lista as caracter√≠sticas que queremos conhecer
  `Caracter√≠stica` = c(
    "Total de clientes", "Satisfa√ß√£o m√©dia (Œº)", "Desvio padr√£o (œÉ)", 
    "% muito satisfeitos (‚â•8)"
  ),
  
  # Calcula os valores populacionais verdadeiros
  `Valor Verdadeiro` = c(
    # Formata o n√∫mero total com separador de milhares
    format(nrow(base_clientes), big.mark = "."),
    # Calcula a satisfa√ß√£o m√©dia populacional real (par√¢metro Œº)
    round(mean(base_clientes$satisfacao), 3),
    # Calcula o desvio padr√£o populacional real (par√¢metro œÉ)
    round(sd(base_clientes$satisfacao), 3),
    # Calcula a propor√ß√£o real de clientes muito satisfeitos
    # mean(base_clientes$satisfacao >= 8) conta a propor√ß√£o com satisfa√ß√£o ‚â• 8
    paste0(round(mean(base_clientes$satisfacao >= 8) * 100, 1), "%")
  )
)

# Mostra as caracter√≠sticas populacionais (desconhecidas na pr√°tica)
parametros_satisfacao

# PESQUISA: Simula o processo de coleta de dados que o analista executaria
# slice_sample(n = 80) seleciona aleatoriamente 80 clientes para entrevistar
amostra_clientes <- base_clientes %>%
  slice_sample(n = 80)

# Calcula os RESULTADOS DA PESQUISA - estat√≠sticas amostrais dispon√≠veis
resultados_pesquisa <- tibble(
  # Lista os resultados que a pesquisa fornece
  `Resultado` = c(
    "Clientes entrevistados", "Satisfa√ß√£o m√©dia (xÃÑ)", "Desvio padr√£o (s)", 
    "% muito satisfeitos"
  ),
  
  # Calcula os valores que o analista realmente obt√©m da amostra
  `Valor` = c(
    # Conta quantos clientes foram efetivamente entrevistados
    nrow(amostra_clientes),
    # Calcula a satisfa√ß√£o m√©dia da amostra (estat√≠stica xÃÑ)
    round(mean(amostra_clientes$satisfacao), 3),
    # Calcula o desvio padr√£o da amostra (estat√≠stica s)
    round(sd(amostra_clientes$satisfacao), 3),
    # Calcula a propor√ß√£o amostral de muito satisfeitos
    paste0(round(mean(amostra_clientes$satisfacao >= 8) * 100, 1), "%")
  ),
  
  # Explica como interpretar cada resultado para o neg√≥cio
  `Interpreta√ß√£o` = c(
    "Tamanho da amostra", 
    "estimativa de Œº", 
    "estimativa do œÉ", 
    "estimativa da % de clientes altamente satisfeitos"
  )
)

# Mostra os resultados que o analista apresentaria para a empresa
resultados_pesquisa
```




## Quiz 1

**Cen√°rio:** Empresa com 8.000 garrafas de vinho. Analista seleciona 
120 garrafas para avalia√ß√£o de qualidade por especialistas.

**Identifique:**

1. Qual √© a popula√ß√£o?
2. Qual √© a amostra?
3. O que representa $\mu$?
4. O que representa $\bar{x}$?
5. Por que n√£o avaliar todas as garrafas?




## Quiz 2

**Cen√°rio:** Rede com 1.200 farm√°cias. Analista seleciona 80 lojas para 
estudar ticket m√©dio.

**Identifique:**

1. Qual √© a popula√ß√£o?
2. Qual √© a amostra?
3. O que representa $\mu$?
4. O que representa $\bar{x}$?
5. Vantagens da abordagem amostral?





# Amostragem 

## O que √© Amostragem?

**Amostragem** √© o processo de selecionar um subconjunto 
representativo de uma popula√ß√£o.

**Caracter√≠sticas de uma Boa Amostra:**

- **Representativa**: Reflete caracter√≠sticas da popula√ß√£o
- **Tamanho adequado**: Equilibra precis√£o e custo
- **Sem vi√©s**: Processo n√£o favorece grupos espec√≠ficos
- **Aleat√≥ria**: Em amostragem probabil√≠stica, probabilidade conhecida 
de sele√ß√£o

**Princ√≠pio fundamental**: Apenas amostras probabil√≠sticas permitem 
infer√™ncia estat√≠stica v√°lida.



## Amostragem Aleat√≥ria Simples em R

Exemplo com Dados Municipais do PNUD (`pnud_muni`)

```{r}
# Carregar pacotes
library(abjData)   # Fornece dados municipais do PNUD

# Carregar a base completa
data("pnud_muni")

# Filtrar apenas os dados mais recentes
dados_recentes <- pnud_muni %>%
  filter(ano == max(ano))  # ano mais recente dispon√≠vel

# Verificar estrutura
glimpse(dados_recentes)
```





## Amostragem Estratificada com o pacote `sampling`

Exemplo com Dados Municipais do PNUD (`pnud_muni`)

```{r}
# Carregar base de dados e filtrar o ano mais recente
data("pnud_muni")
dados_recentes <- pnud_muni %>%
  filter(ano == max(ano)) %>%
  select(uf, municipio, pop, espvida, rdpc, idhm)

# Tamanho total da amostra desejada
n_total <- 150

# Calcular tamanho proporcional da amostra por UF
tamanhos <- dados_recentes %>%
  # Contar o n√∫mero de munic√≠pios em cada UF
  count(uf, name = "n_uf") %>%
  # Calcular a propor√ß√£o de munic√≠pios da UF em rela√ß√£o ao total de munic√≠pios
  mutate(
    prop = n_uf / sum(n_uf),
    # Determinar o tamanho da amostra da UF proporcional ao total desejado
    n_amostra = round(prop * n_total),
    # Corrigir poss√≠veis casos com zero observa√ß√µes (garante m√≠nimo de 1)
    n_amostra = if_else(n_amostra == 0, 1L, n_amostra)
  )


# Realizar amostragem estratificada proporcional
set.seed(123)
amostra_ids <- sampling::strata(
  data = dados_recentes,           # data frame com a popula√ß√£o (munic√≠pios do ano mais recente)
  stratanames = "uf",              # vari√°vel que define os estratos 
  size = tamanhos$n_amostra,       # n√∫mero de unidades a serem sorteadas por estrato (UF)
  method = "srswor"                # aas sem reposi√ß√£o
)

# Selecionar observa√ß√µes da amostra
amostra_proporcional <- dados_recentes[amostra_ids$ID_unit, ]
```

üëâ A fun√ß√£o `strata()` sorteia munic√≠pios **proporcionalmente √† quantidade por UF**, garantindo pelo menos 1 munic√≠pio por estado.

üëâ `ID_unit` cont√©m os √≠ndices sorteados que usamos para extrair a 
amostra final.




## Visualizando a Amostra Estratificada

Quantos Munic√≠pios Foram Sorteados por UF?

```{r}
# Contar n√∫mero de munic√≠pios sorteados por UF
amostra_proporcional %>%
  count(uf, name = "n_sorteados") %>%
  arrange(desc(n_sorteados))
```





## Exerc√≠cio

Aplicar os conceitos aprendidos de amostragem aos dados do PNUD:

1. Filtrar os dados para o ano mais recente dispon√≠vel
2. Criar uma **amostra estratificada proporcional por UF** com 150 munic√≠pios
3. Estime a m√©dia do IDHM da amostra estratificada

- Dicas:

- Use a base `pnud_muni` do pacote `abjData`
- Utilize `set.seed(123)` para reprodutibilidade
- Para a amostragem estratificada, siga o padr√£o visto nos slides anteriores





# Par√¢metro, Estimador, Estat√≠stica e Estimativa 


## Quiz 3

Identifique: Par√¢metro, Estimador, Estat√≠stica ou Estimativa?

Uma empresa de e-commerce analisa seus pedidos:

1. A f√≥rmula $S^2 = \frac{\sum(X_i - \bar{X})^2}{n-1}$ para calcular vari√¢ncia
2. O valor R$ 127,50 calculado como m√©dia de 1.000 pedidos
3. A verdadeira propor√ß√£o de clientes satisfeitos (nota ‚â• 8)
4. A vari√°vel aleat√≥ria $\hat{p}$ = propor√ß√£o amostral de satisfeitos
5. O desvio padr√£o œÉ = R$ 45,00 de todos os pedidos hist√≥ricos




# Distribui√ß√£o Amostral 

## O Problema Central da Infer√™ncia Estat√≠stica 

Um analista de dados coleta uma amostra de 100 funcion√°rios e calcula satisfa√ß√£o m√©dia $\bar{x} = 7.2$. Mas se ele repetisse o processo com outra amostra de 100 funcion√°rios, obteria $\bar{x} = 7.0$. Uma terceira amostra resultaria em $\bar{x} = 7.4$.

**A Distribui√ß√£o Amostral** √© a distribui√ß√£o de probabilidade de todas as poss√≠veis m√©dias amostrais que poder√≠amos obter se repet√≠ssemos o processo de amostragem infinitas vezes.

**Por que isso √© importante?** A distribui√ß√£o amostral nos permite quantificar a variabilidade dos estimadores e fundamenta todos os m√©todos de infer√™ncia estat√≠stica.




## Simula√ß√£o: Visualizando uma Distribui√ß√£o Amostral

Simularemos 1.000 amostras diferentes para observar como as m√©dias amostrais se distribuem. Isso permitir√° visualizar concretamente o conceito de distribui√ß√£o amostral.

**Cen√°rio**: Popula√ß√£o de 50.000 funcion√°rios com satisfa√ß√£o m√©dia $\mu = 7.5$ e desvio-padr√£o $\sigma = 1.2$. Cada amostra ter√° 50 funcion√°rios.


```{r}
#| echo: false

# Fixa a semente para garantir que todos obtenham os mesmos resultados
set.seed(456)

# Simula uma popula√ß√£o grande de funcion√°rios
populacao_funcionarios <- tibble(
  # Cria IDs √∫nicos de 1 a 50.000
  id = 1:50000,
  # Gera satisfa√ß√£o usando distribui√ß√£o normal
  # rnorm() cria n√∫meros aleat√≥rios normais
  # mean = 7.5 define a m√©dia populacional
  # sd = 1.2 define o desvio padr√£o populacional
  satisfacao = rnorm(50000, mean = 7.5, sd = 1.2)
)

# Ajusta valores para ficarem entre 0 e 10 (escala de satisfa√ß√£o)
# pmin() garante que nenhum valor seja maior que 10
# pmax() garante que nenhum valor seja menor que 0
populacao_funcionarios <- populacao_funcionarios %>%
  mutate(satisfacao = pmin(10, pmax(0, satisfacao)))

# Calcula os par√¢metros populacionais verdadeiros
# Estes s√£o os valores que queremos estimar com nossas amostras
parametros_populacionais <- tibble(
  Par√¢metro = c("Œº (m√©dia populacional)", "œÉ (desvio populacional)", "N (tamanho)"),
  Valor = c(
    round(mean(populacao_funcionarios$satisfacao), 3),
    round(sd(populacao_funcionarios$satisfacao), 3),
    nrow(populacao_funcionarios)
  )
)

# Exibe os par√¢metros populacionais
parametros_populacionais

# Agora vamos simular o processo de coleta de muitas amostras
# Cada amostra ter√° 50 funcion√°rios
n_amostra <- 50
n_simulacoes <- 1000

# Cria lista para armazenar todas as m√©dias amostrais
medias_amostrais <- numeric(n_simulacoes)  # Vetor vazio para 1000 m√©dias

# Loop para coletar 1000 amostras e calcular suas m√©dias
for(i in 1:n_simulacoes) {
  # Coleta uma amostra aleat√≥ria de 50 funcion√°rios
  amostra_atual <- populacao_funcionarios %>%
    slice_sample(n = n_amostra)
  
  # Calcula a m√©dia desta amostra e armazena
  medias_amostrais[i] <- mean(amostra_atual$satisfacao)
}

# Analisa as propriedades da distribui√ß√£o amostral
resultados_simulacao <- tibble(
  Propriedade = c(
    "M√©dia das m√©dias amostrais", 
    "Erro padr√£o emp√≠rico (observado)",
    "Erro padr√£o te√≥rico (f√≥rmula)",
    "M√©dia populacional (Œº)",
    "Diferen√ßa (emp√≠rico - te√≥rico)"
  ),
  Valor = c(
    round(mean(medias_amostrais), 3),
    round(sd(medias_amostrais), 3),
    round(sd(populacao_funcionarios$satisfacao) / sqrt(n_amostra), 3),
    round(mean(populacao_funcionarios$satisfacao), 3),
    round(sd(medias_amostrais) - sd(populacao_funcionarios$satisfacao) / sqrt(n_amostra), 3)
  )
)

# Exibe os resultados da simula√ß√£o
resultados_simulacao
```




## Visualizando a Distribui√ß√£o Amostral

```{r}
#| echo: false

# Prepara dados para criar os gr√°ficos comparativos
dados_para_grafico <- tibble(medias = medias_amostrais)

# Cria gr√°fico da popula√ß√£o original (uma amostra para visualiza√ß√£o)
# Usamos sample_n() para pegar apenas 2000 observa√ß√µes (facilita visualiza√ß√£o)
amostra_pop_grafico <- populacao_funcionarios %>% 
  sample_n(2000)

p1 <- amostra_pop_grafico %>%
  ggplot(aes(x = satisfacao)) +
  # geom_histogram() cria histograma
  # aes(y = after_stat(density)) converte frequ√™ncias em densidades
  geom_histogram(aes(y = after_stat(density)), 
                 bins = 30, fill = "#95a5a6", alpha = 0.7, color = "white") +
  # geom_vline() adiciona linha vertical na m√©dia populacional
  geom_vline(xintercept = mean(populacao_funcionarios$satisfacao), 
             color = "#e74c3c", linewidth = 1.5, linetype = "dashed") +
  labs(title = "Popula√ß√£o Original",
       subtitle = paste("N = 50.000, Œº =", round(mean(populacao_funcionarios$satisfacao), 2)),
       x = "Satisfa√ß√£o Individual", y = "Densidade") +
  theme_minimal()

# Cria gr√°fico da distribui√ß√£o amostral das m√©dias
p2 <- ggplot(dados_para_grafico, aes(x = medias)) +
  geom_histogram(aes(y = after_stat(density)), 
                 bins = 40, fill = "#3498db", alpha = 0.7, color = "white") +
  # Adiciona linha na m√©dia populacional verdadeira
  geom_vline(xintercept = mean(populacao_funcionarios$satisfacao), 
             color = "#2c3e50", linewidth = 1.5, linetype = "dashed") +
  labs(title = "Distribui√ß√£o Amostral das M√©dias",
       subtitle = paste("1000 amostras, n = 50, SE =", round(sd(medias_amostrais), 3)),
       x = "M√©dias Amostrais", y = "Densidade") +
  theme_minimal()

# Combina os dois gr√°ficos verticalmente
# O operador / do patchwork empilha gr√°ficos
p1 / p2
```




## Simula√ß√£o: Propor√ß√£o de Clientes Satisfeitos

```{r}
#| echo: false

# Simula popula√ß√£o de clientes onde cada um pode estar satisfeito ou n√£o
set.seed(789)

# Define a propor√ß√£o populacional verdadeira de clientes satisfeitos
p_populacional <- 0.68  # 68% dos clientes est√£o satisfeitos

# Cria popula√ß√£o de clientes
# rbinom() gera vari√°veis bin√°rias (0 ou 1)
# size = 1 significa cada "experimento" tem apenas 1 tentativa
# prob = p_populacional define a probabilidade de sucesso (satisfeito = 1)
populacao_clientes <- tibble(
  cliente_id = 1:20000,
  satisfeito = rbinom(20000, size = 1, prob = p_populacional)
)

# Calcula a propor√ß√£o real obtida na popula√ß√£o simulada
# mean() de 0s e 1s nos d√° a propor√ß√£o de 1s
p_real_populacao <- mean(populacao_clientes$satisfeito)

# Mostra caracter√≠sticas da popula√ß√£o
caracteristicas_pop_clientes <- tibble(
  Caracter√≠stica = c("Tamanho da popula√ß√£o", "Propor√ß√£o satisfeitos (p)", "N√∫mero de satisfeitos"),
  Valor = c(
    nrow(populacao_clientes),
    round(p_real_populacao, 3),
    sum(populacao_clientes$satisfeito)
  )
)

# Exibe caracter√≠sticas da popula√ß√£o
caracteristicas_pop_clientes

# Agora simula muitas pesquisas para ver como as propor√ß√µes amostrais variam
n_amostra_prop <- 100  # Cada pesquisa ter√° 100 clientes
n_simulacoes_prop <- 800  # Faremos 800 pesquisas

# Cria vetor para armazenar as propor√ß√µes de cada pesquisa
proporcoes_amostrais <- numeric(n_simulacoes_prop)

# Loop para realizar 800 pesquisas diferentes
for(i in 1:n_simulacoes_prop) {
  # Realiza uma pesquisa: amostra 100 clientes
  pesquisa_atual <- populacao_clientes %>%
    slice_sample(n = n_amostra_prop)
  
  # Calcula propor√ß√£o de satisfeitos nesta pesquisa
  # mean() de vari√°vel bin√°ria = propor√ß√£o de 1s
  proporcoes_amostrais[i] <- mean(pesquisa_atual$satisfeito)
}

# Analisa os resultados das 800 pesquisas
analise_proporcoes <- tibble(
  Estat√≠stica = c(
    "Propor√ß√£o populacional (p)",
    "M√©dia das propor√ß√µes amostrais",
    "Erro padr√£o emp√≠rico (observado)",
    "Erro padr√£o te√≥rico (f√≥rmula)",
    "Diferen√ßa entre erros padr√£o"
  ),
  Valor = c(
    round(p_real_populacao, 3),
    round(mean(proporcoes_amostrais), 3),
    round(sd(proporcoes_amostrais), 3),
    round(sqrt(p_real_populacao * (1 - p_real_populacao) / n_amostra_prop), 3),
    round(sd(proporcoes_amostrais) - sqrt(p_real_populacao * (1 - p_real_populacao) / n_amostra_prop), 3)
  )
)

# Exibe an√°lise das propor√ß√µes
analise_proporcoes
```




## Visualizando a Distribui√ß√£o Amostral da Propor√ß√£o

```{r}
#| echo: false

# Prepara dados para o gr√°fico
dados_proporcao <- tibble(proporcoes = proporcoes_amostrais)

# Cria gr√°fico da distribui√ß√£o amostral das propor√ß√µes
ggplot(dados_proporcao, aes(x = proporcoes)) +
  # Histograma das propor√ß√µes observadas nas 800 pesquisas
  geom_histogram(aes(y = after_stat(density)), 
                 bins = 25, fill = "#9b59b6", alpha = 0.7, color = "white") +
  # Adiciona curva normal te√≥rica para compara√ß√£o
  # stat_function() plota uma fun√ß√£o matem√°tica
  stat_function(fun = dnorm, 
                args = list(mean = p_real_populacao, 
                           sd = sqrt(p_real_populacao * (1 - p_real_populacao) / n_amostra_prop)),
                color = "#2c3e50", linewidth = 1.2, linetype = "dashed") +
  # Linha vertical na propor√ß√£o populacional verdadeira
  geom_vline(xintercept = p_real_populacao, 
             color = "#2c3e50", linewidth = 1.5, linetype = "dotted") +
  labs(title = "Distribui√ß√£o Amostral da Propor√ß√£o",
       subtitle = paste("800 pesquisas de n =", n_amostra_prop, "- Curva tracejada = distribui√ß√£o normal te√≥rica"),
       x = "Propor√ß√µes Amostrais", 
       y = "Densidade") +
  theme_minimal()
```




## Teorema Central do Limite

Usaremos uma distribui√ß√£o exponencial (altamente assim√©trica) para demonstrar que m√©dias amostrais tendem √† normalidade independentemente da forma populacional.

**Cen√°rio**: Tempo entre chegadas de clientes (distribui√ß√£o exponencial - muitas chegadas r√°pidas, poucas esperas longas).


```{r}
#| echo: false

# Cria popula√ß√£o com distribui√ß√£o exponencial (muito diferente da normal)
set.seed(111)

# rexp() gera n√∫meros aleat√≥rios com distribui√ß√£o exponencial
# rate = 0.3 controla a "velocidade" da exponencial (maior rate = valores menores)
populacao_exponencial <- tibble(
  id = 1:10000,
  tempo_espera = rexp(10000, rate = 0.3)
)

# Calcula caracter√≠sticas da popula√ß√£o exponencial
caracteristicas_exp <- tibble(
  Caracter√≠stica = c("M√©dia populacional", "Desvio padr√£o populacional", "Forma da distribui√ß√£o"),
  Valor = c(
    round(mean(populacao_exponencial$tempo_espera), 2),
    round(sd(populacao_exponencial$tempo_espera), 2),
    "Exponencial (muito assim√©trica)"
  )
)

# Exibe caracter√≠sticas
caracteristicas_exp

# Agora vamos testar diferentes tamanhos de amostra
tamanhos_tcl <- c(2, 10, 40)

# Lista para armazenar dados de cada tamanho
dados_tcl_lista <- list()

# Loop pelos tamanhos de amostra
for(k in 1:length(tamanhos_tcl)) {
  tamanho_tcl_atual <- tamanhos_tcl[k]
  
  # Coleta 500 m√©dias amostrais para este tamanho
  medias_tcl <- numeric(500)
  
  for(i in 1:500) {
    # Amostra do tamanho especificado
    amostra_tcl <- populacao_exponencial %>%
      slice_sample(n = tamanho_tcl_atual)
    
    # Calcula m√©dia
    medias_tcl[i] <- mean(amostra_tcl$tempo_espera)
  }
  
  # Armazena dados com r√≥tulo do tamanho
  dados_tcl_k <- tibble(
    tamanho = paste("n =", tamanho_tcl_atual),
    media = medias_tcl
  )
  
  dados_tcl_lista[[k]] <- dados_tcl_k
}

# Adiciona dados da popula√ß√£o original para compara√ß√£o
# sample() para pegar apenas 1000 valores (facilita visualiza√ß√£o)
dados_pop_original <- tibble(
  tamanho = "Popula√ß√£o\n(Exponencial)",
  media = sample(populacao_exponencial$tempo_espera, 1000)
)

# Combina todos os dados
dados_tcl_completos <- bind_rows(dados_pop_original, dados_tcl_lista)

# Define ordem correta para os gr√°ficos
# factor() com levels= controla a ordem de exibi√ß√£o
dados_tcl_completos <- dados_tcl_completos %>%
  mutate(tamanho = factor(tamanho, 
                         levels = c("Popula√ß√£o\n(Exponencial)", "n = 2", "n = 10", "n = 40")))

# Verifica quantas observa√ß√µes temos para cada grupo
resumo_tcl <- dados_tcl_completos %>%
  count(tamanho, name = "n_observacoes")

# Exibe resumo
resumo_tcl
```





## TCL: Visualizando a Converg√™ncia para Normalidade


```{r}
#| echo: false

# Cria gr√°fico mostrando a transforma√ß√£o de assim√©trica para normal
ggplot(dados_tcl_completos, aes(x = media)) +
  # Histograma para cada grupo (tamanho de amostra)
  geom_histogram(bins = 30, fill = "#3498db", alpha = 0.7, color = "white") +
  # facet_wrap() cria pain√©is separados para cada grupo
  # scales = "free" permite que cada painel tenha sua pr√≥pria escala
  facet_wrap(~tamanho, scales = "free", ncol = 2) +
  labs(title = "Teorema Central do Limite em A√ß√£o",
       subtitle = "Note como a distribui√ß√£o se torna mais normal conforme n aumenta",
       x = "Valores / M√©dias Amostrais",
       y = "Frequ√™ncia") +
  theme_minimal() +
  # Personaliza apar√™ncia dos t√≠tulos dos pain√©is
  theme(strip.text = element_text(size = 11, face = "bold"))
```




## Quiz 4: Distribui√ß√µes Amostrais

1. Para uma amostra de 36 observa√ß√µes com desvio-padr√£o s = 1.8, o 
erro-padr√£o de $\bar{x}$ √©:

    a. 0.05
    b. 0.30
    c. 1.8
    d. 6.0

2. Para reduzir o erro-padr√£o de $\bar{x}$ pela metade, o tamanho 
da amostra deve ser:

    a. Dobrado
    b. Quadruplicado
    c. Reduzido pela metade
    d. Triplicado

3. O Teorema Central do Limite se refere √† distribui√ß√£o:

    a. Da popula√ß√£o
    b. Da amostra
    c. Amostral do estimador
    d. Normal padr√£o






